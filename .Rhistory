}
calculate_phi_sn(2, 2, 2, 2)
calculate_phi_at = function(three_hour, place, cloud_fraction, day_arg, year_arg){
# Get the time in hour
hour = time_of_the_day[three_hour]
# load the diurnal air temperature data
air_temp = read.csv("diurnal_air_temp.csv")
air_temp = air_temp[air_temp$time == hour, ]
air_temp = air_temp[air_temp$day == day_arg, ]
air_temp = air_temp[air_temp$year == year_arg, ]
air_temp = air_temp[air_temp$area == areas[place], ]
t_ak = air_temp$air_temp # Already in Kelvin
# t_ak = ((tmax_air + tmin_air)/2 + (tmax_air - tmin_air)*0.4484 *(sin(2*(pi/24)*(hour + 6) - 2.7489) + 0.2706 * sin(2 * (2 * (pi/24)* (hour + 6) - 2.7489)))) + 273.15
e = (0.398 * (10 ** (-5)))*(t_ak ** (2.148))
r = 0.03 # reflectance of the water surface to longwave radiation
sigma = 2.07 * (10 ** (-7)) # Stefan-Boltzman constant, unit Kg/m2/hr/K^4
phi_at = ((1 - r)* e * sigma * (t_ak ** (4))) * (1 + 0.17 * (cloud_fraction ** 2)) # this calculates phi_at for one hour
# phi_at for three hours
three_hours_phi_at = phi_at * 3
return(three_hours_phi_at)
}
calculate_phi_at(1, 2, 0.3, 2, 2001)
calculate_phi_at(5, 2, 0.3, 2, 2001)
calculate_phi_sn(2, 2, 6, 2)
calculate_phi_at = function(three_hour, place, cloud_fraction, day_arg, year_arg){
# Get the time in hour
hour = time_of_the_day[three_hour]
# load the diurnal air temperature data
air_temp = read.csv("diurnal_air_temp.csv")
air_temp = air_temp[air_temp$time == hour, ]
air_temp = air_temp[air_temp$day == day_arg, ]
air_temp = air_temp[air_temp$year == year_arg, ]
air_temp = air_temp[air_temp$area == areas[place], ]
t_ak = air_temp$air_temp # Already in Kelvin
# t_ak = ((tmax_air + tmin_air)/2 + (tmax_air - tmin_air)*0.4484 *(sin(2*(pi/24)*(hour + 6) - 2.7489) + 0.2706 * sin(2 * (2 * (pi/24)* (hour + 6) - 2.7489)))) + 273.15
e = (0.398 * (10 ** (-5)))*(t_ak ** (2.148))
r = 0.03 # reflectance of the water surface to longwave radiation
sigma = 2.07 * (10 ** (-7)) # Stefan-Boltzman constant, unit Kg/m2/hr/K^4
phi_at = ((1 - r)* e * sigma * (t_ak ** (4))) * (1 + 0.17 * (cloud_fraction ** 2)) # this calculates phi_at for one hour
# phi_at for three hours
three_hours_phi_at = phi_at * 3
return(three_hours_phi_at)
}
calculate_phi_at(6, 2, 0.3, 2, 2001)
calculate_phi_at(6, 2, 0.3, 2, 2017)
calculate_phi_ws = function(place, three_hour, layer_no, day_arg, year_arg){
# T_wk is the water surface temperature in Kelvin
# The following file heat_layers.csv contains the output of the simulation
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
print(paste0("Inside calculate_phi_ws(), the value of day is: ", day_arg))
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wk = heat_layers$temp + 273.15
# T_wk = heat_layers$temp
# Calculate hourly phi_ws
phi_ws = 0.97 * sigma_const * (T_wk^4)
# Now, calculate three-hourly phi_ws
three_hours_phi_ws = phi_ws * 3
# Return phi_ws for three hours or three_hours_phi_ws
return(three_hours_phi_ws)
}
calculate_phi_ws(2, 1, 1, 1, 2017)
data_air = read.csv("long_term_air_temp.csv")
data_air = data_air[data_air$day == 1, ]
data_air_sri = data_air[data_air$area == areas[1], ]
data_air_sri = data_air_sri[data_air_sri$hour == 6, ]
data_air_khu = data_air[data_air$area == areas[2], ]
data_air_khu = data_air_khu[data_air_khu$hour == 6, ]
initial_temp_sri = data_air_sri$mean_temp - 273.15
initial_temp_khu = data_air_khu$mean_temp - 273.15
simulated_data = data.frame(layer = rep(c(1,2,3),2), time = rep(6, 6), day = rep(1, 6), year = rep(2017, 6), heat = rep(0, 6), temp = c(rep(initial_temp_sri, 3), rep(initial_temp_khu, 3)), area = c(rep(areas[1], 3), rep(areas[2], 3)))
View(simulated_data)
write.csv(simulated_data, paste0("simulated_data.csv"))
calculate_phi_ws(2, 1, 1, 1, 2017)
calculate_phi_ws(2, 2, 1, 1, 2017)
place
three_hour
three_hour=2
layer_no
layer_no=1
day_arg=1
year_arg
# The following file heat_layers.csv contains the output of the simulation
heat_layers = read.csv("simulated_data.csv")
View(heat_layers)
View(heat_layers)
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
View(heat_layers)
# The following file heat_layers.csv contains the output of the simulation
heat_layers = read.csv("simulated_data.csv")
View(heat_layers)
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
View(heat_layers)
calculate_phi_ws(2, 4, 1, 1, 2017)
calculate_phi_e = function(i, place, three_hour, layer_no, day_arg, year_arg){
# N, empirical coefficient from Lake Hefner, unit KJm-2km-1mmHg-1
N = 5.0593
daily_data = read_met_data(i, place)
# solar_daily = daily_data$insolation
wind_speed_2m = daily_data$wind_speed_2m
# wind speed 2 m above the surface
W2 = wind_speed_2m
# T_wc is water surface temperature in Celsius
# The following file heat_layers.csv contains the output of the simulation
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
tmin_air_data = daily_data[daily_data$district == areas[place], ]
tmin_air = tmin_air_data$min_temp
# T_d is the average daily dew-point temperature
# Using morning minimum temperature as the morning minimum dry-bulb temperature
T_d = (tmin_air - 2) + 273.15 # from page 235 of the Culberson paper. Adding 273.15 to convert to Kelvin
# e_s, saturated vapor pressure at T_wc; unit mmHg
e_s = 25.375 * exp(17.62 - (5271 / T_wc))
# e_a, water vapor pressure above the pond surface; unit mmHg
e_a = 610.78 * exp(17.2694 *((T_d - 273.16)/(T_d - 35.86)))
phi_e = N * W2 * (e_s - e_a)
three_hours_phi_e = 3 * phi_e
# Return phi_e for three hours or three_hours_phi_e
return(three_hours_phi_e)
}
calculate_phi_e(2, 2, 4, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
calculate_phi_e(2, 2, 2, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
calculate_phi_e(1, 2, 2, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
calculate_phi_e(1, 2, 4, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
calculate_phi_c = function(i, place, three_hour, layer_no, day_arg, year_arg){
# wind speed 2 m above the surface
daily_data =read_met_data(i, place)
wind_speed_2m = daily_data$wind_speed_2m
W2 = wind_speed_2m[place]
# T_wc is water surface temperature in Celsius
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
# Get the time in hour
hour = time_of_the_day[three_hour]
# load the diurnal air temperature data
air_temp = read.csv("diurnal_air_temp.csv")
air_temp = air_temp[air_temp$time == hour, ]
air_temp = air_temp[air_temp$day == day_arg, ]
air_temp = air_temp[air_temp$year == year_arg, ]
air_temp = air_temp[air_temp$area == areas[place], ]
# Air temperature in degree Celsius
T_ac = air_temp$air_temp
# phi_c, sensible heat transfer
phi_c = 1.5701 * W2 * (T_wc - T_ac)
three_hours_phi_c = phi_c * 3
# Return phi_c for three hours or three_hours_phi_c
return(three_hours_phi_c)
}
calculate_phi_c(1, 2, 4, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
calculate_phi_c = function(i, place, three_hour, layer_no, day_arg, year_arg){
# wind speed 2 m above the surface
daily_data =read_met_data(i, place)
wind_speed_2m = daily_data$wind_speed_2m
W2 = wind_speed_2m[place]
# T_wc is water surface temperature in Celsius
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
# Get the time in hour
hour = time_of_the_day[three_hour]
# load the diurnal air temperature data
air_temp = read.csv("diurnal_air_temp.csv")
air_temp = air_temp[air_temp$time == hour, ]
air_temp = air_temp[air_temp$day == day_arg, ]
air_temp = air_temp[air_temp$year == year_arg, ]
air_temp = air_temp[air_temp$area == areas[place], ]
# Air temperature in degree Celsius
T_ac = air_temp$air_temp
# phi_c, sensible heat transfer
phi_c = 1.5701 * W2 * (T_wc - T_ac)
three_hours_phi_c = phi_c * 3
# Return phi_c for three hours or three_hours_phi_c
return(three_hours_phi_c)
}
calculate_phi_c(1, 2, 4, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
i=1
place=2
three_hour
three_hour=4
layer_no
day_arg
year_arg
# wind speed 2 m above the surface
daily_data =read_met_data(i, place)
wind_speed_2m = daily_data$wind_speed_2m
W2 = wind_speed_2m[place]
W2
wind_speed_2m
W2 = wind_speed_2m
# T_wc is water surface temperature in Celsius
heat_layers = read.csv("simulated_data.csv")
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
T_wc
# Get the time in hour
hour = time_of_the_day[three_hour]
hour
# load the diurnal air temperature data
air_temp = read.csv("diurnal_air_temp.csv")
air_temp = air_temp[air_temp$time == hour, ]
air_temp = air_temp[air_temp$day == day_arg, ]
air_temp = air_temp[air_temp$year == year_arg, ]
air_temp = air_temp[air_temp$area == areas[place], ]
# Air temperature in degree Celsius
T_ac = air_temp$air_temp
T_ac
phi_c = 1.5701 * W2 * (T_wc - T_ac)
three_hours_phi_c = phi_c * 3
three_hours_phi_c
calculate_phi_c = function(i, place, three_hour, layer_no, day_arg, year_arg){
# wind speed 2 m above the surface
daily_data =read_met_data(i, place)
wind_speed_2m = daily_data$wind_speed_2m
W2 = wind_speed_2m
# T_wc is water surface temperature in Celsius
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
# Get the time in hour
hour = time_of_the_day[three_hour]
# load the diurnal air temperature data
air_temp = read.csv("diurnal_air_temp.csv")
air_temp = air_temp[air_temp$time == hour, ]
air_temp = air_temp[air_temp$day == day_arg, ]
air_temp = air_temp[air_temp$year == year_arg, ]
air_temp = air_temp[air_temp$area == areas[place], ]
# Air temperature in degree Celsius
T_ac = air_temp$air_temp
# phi_c, sensible heat transfer
phi_c = 1.5701 * W2 * (T_wc - T_ac)
three_hours_phi_c = phi_c * 3
# Return phi_c for three hours or three_hours_phi_c
return(three_hours_phi_c)
}
calculate_phi_c(1, 2, 4, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
calculate_phi_sn_z(2, 1, 4, 1.5, 1, 1)
calculate_phi_sn_z = function(i, place, three_hour, sdd, layer_number, day_arg){
solar_data = get_day_length(place, day_arg) # get_day_length(place, day_arg)
phi_sn = calculate_phi_sn(i, day_arg, three_hour, place)
# Calculate solar altitude angle lambda
lambda = abs(Altitude(day_arg, latitude[place], longitude[place], longitude[place], 0))
# Calculate R_s
R_s = 2.2 * (180 * lambda/pi)^(-0.97)
# W_z is wind velocity at 2 meters above the pond surface
daily_data = read_met_data(i, place)
wind_speed_2m = daily_data$wind_speed_2m
W_z = wind_speed_2m
# Calculate R, reflectivity adjusted for surface temperature
R = R_s * (1 - 0.08 * W_z)
# beta, fraction of solar irradiance absorbed at surface
beta = 0.03
# n_e, effective light extinction coefficient
n_e = 1.7 /sdd # For now, assume sdd could be as much as the pond depth, 5 ft or 1.5204 m
# Calculate z, the depth for a layer
z = each_layer_depth + (layer_number - 1) * each_layer_depth
# calculate phi_sn_z
phi_sn_z = phi_sn * (1 - R) * (1 - beta) * exp(-1 * n_e * z)
# calculate three-hourly phi_sn_z
three_hours_phi_sn_z = 3 * phi_sn_z
return(three_hours_phi_sn_z)
}
calculate_phi_sn_z(2, 1, 4, 1.5, 1, 1)
get_day_length = function(place, day_arg){
# Get the latitude for the place
lat = latitude[place]
# Compute the sunrise and sunset time using functions from solrad package
# This will give us the day length which we can then use for computing
# solar irradiance for 3 hours computing from solar irradiance for a day as
# provided in the NASA LARC dataset
# sunrise = Sunrise(day, lat)
sunset = Sunset(day_arg, lat)
# Compute the day length
# Sunrise() gives back the time when the sun rises in AM
# Sunset() gives the sunset time in PM.
# So, to compute the day_length, we subtract sunrise from 12 and add the sunset time in PM
# to get the day_length
# day_length = (12 - sunrise) + sunset
day_length = DayLength(day_arg, lat)
sunrise = 12 + sunset - day_length
# Make a list comprising of sunrise, sunset and day_length and return this
solar_list = list("sunrise" = sunrise, "sunset" = sunset, "day_length" = day_length)
return(solar_list)
}
calculate_phi_c = function(i, place, three_hour, layer_no, day_arg, year_arg){
# wind speed 2 m above the surface
daily_data =read_met_data(i, place)
wind_speed_2m = daily_data$wind_speed_2m
W2 = wind_speed_2m
# T_wc is water surface temperature in Celsius
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
# Get the time in hour
hour = time_of_the_day[three_hour]
# load the diurnal air temperature data
air_temp = read.csv("diurnal_air_temp.csv")
air_temp = air_temp[air_temp$time == hour, ]
air_temp = air_temp[air_temp$day == day_arg, ]
air_temp = air_temp[air_temp$year == year_arg, ]
air_temp = air_temp[air_temp$area == areas[place], ]
# Air temperature in degree Celsius
T_ac = air_temp$air_temp
# phi_c, sensible heat transfer
phi_c = 1.5701 * W2 * (T_wc - T_ac)
three_hours_phi_c = phi_c * 3
# Return phi_c for three hours or three_hours_phi_c
return(three_hours_phi_c)
}
calculate_phi_c(1, 2, 4, 1, 1, 2017) # (i, place, three_hour, layer_no, day_arg, year_arg)
calculate_phi_sn_z = function(i, place, three_hour, sdd, layer_number, day_arg){
solar_data = get_day_length(place, day_arg) # get_day_length(place, day_arg)
phi_sn = calculate_phi_sn(i, day_arg, three_hour, place)
# Calculate solar altitude angle lambda
lambda = abs(Altitude(day_arg, latitude[place], longitude[place], longitude[place], 0))
# Calculate R_s
R_s = 2.2 * (180 * lambda/pi)^(-0.97)
# W_z is wind velocity at 2 meters above the pond surface
daily_data = read_met_data(i, place)
wind_speed_2m = daily_data$wind_speed_2m
W_z = wind_speed_2m
# Calculate R, reflectivity adjusted for surface temperature
R = R_s * (1 - 0.08 * W_z)
# beta, fraction of solar irradiance absorbed at surface
beta = 0.03
# n_e, effective light extinction coefficient
n_e = 1.7 /sdd # For now, assume sdd could be as much as the pond depth, 5 ft or 1.5204 m
# Calculate z, the depth for a layer
z = each_layer_depth + (layer_number - 1) * each_layer_depth
# calculate phi_sn_z
phi_sn_z = phi_sn * (1 - R) * (1 - beta) * exp(-1 * n_e * z)
# calculate three-hourly phi_sn_z
three_hours_phi_sn_z = 3 * phi_sn_z
return(three_hours_phi_sn_z)
}
calculate_phi_sn_z(2, 1, 4, 1.5, 1, 1)
calculate_T_sed = function(place, three_hour, day_arg){
# Get the value of the long-term average temperature
all_data = read.csv("long_term_air_temp.csv")
all_data = all_data[all_data$area == areas[place], ]
all_data = all_data[all_data$day == day_arg, ]
all_data = all_data[all_data$hour == time_of_the_day[three_hour], ]
# long_term_avergae_air_temp = unique(all_data)
long_term_avergae_air_temp = all_data$mean_temp - 273.15
rm(all_data)
# Set temperature of the sediment volume element to the long-term average temperature
return(long_term_avergae_air_temp)
}
calculate_T_sed = function(place, three_hour, day_arg){
# Get the value of the long-term average temperature
all_data = read.csv("long_term_air_temp.csv")
all_data = all_data[all_data$area == areas[place], ]
all_data = all_data[all_data$day == day_arg, ]
all_data = all_data[all_data$hour == time_of_the_day[three_hour], ]
# long_term_avergae_air_temp = unique(all_data)
long_term_avergae_air_temp = all_data$mean_temp - 273.15
rm(all_data)
# Set temperature of the sediment volume element to the long-term average temperature
return(long_term_avergae_air_temp)
}
calculate_T_sed(1, 4, 2)
calculate_phi_sed = function(place, three_hour, day_arg, year_arg){
# T_bot = bottom_layer_temp[i, time_of_the_day[three_hour]]
layer_no = 3
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_bot = heat_layers$temp
# Calculate T_sed
T_sed = calculate_T_sed(place, three_hour, day_arg)
# Calculate phi_sed
phi_sed = k_sed * ((T_bot - T_sed) / each_layer_depth) # Use layer depth as the value for delta_z or distance
# between the centers of the volume elements
# Calculate and return three-hourly phi_sed
three_hours_phi_sed = phi_sed * 3
return(three_hours_phi_sed)
}
calculate_phi_sed(1, 4, 1, 2001)
calculate_phi_sed(1, 4, 1, 2017)
# Calculalting phi_gw, heat loss from sediment volume element to ground water table
calculate_phi_gw = function(place, three_hour, day_arg){
k_e = 2.5 # thermal conductivity coefficien for earth, unit kJmh-1r-1C-1
T_gw = 20 # temperature of the ground water, unit degree Celsius
delta_z = 0.2534 # distance between sediment and ground water volume elements, in meters
# Calculate T_sed
T_sed = calculate_T_sed(place, three_hour, day_arg)
phi_gw = k_e * ((T_sed - T_gw)/delta_z)
# Calculate and return three-hourly phi_gw
three_hours_phi_gw = phi_gw * 3
return(three_hours_phi_gw)
}
calculate_phi_gw(1, 4, 1)
calculate_phi_dz = function(place, three_hour, layer_no, day_arg, year_arg){
# T_wc is water surface temperature in Celsius
c_pw = 4.1816 # heat capacity of water, unit kJK-1kg-1
A_v = 1 # idealized volume element surface area
# Calculating T_wc or water temperature in 0 C
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
# Calculating rho_w
rho_w = (0.99987 + (0.69 * (10 ** (-5))) * T_wc) - ((8.89 * (10 ** (-6))) * (T_wc)**2) + ((7.4 * (10 ** (-8))) * (T_wc ** 3)) * 1000
phi_dz = T_wc * rho_w * c_pw * A_v
# Calculate and return three-hourly phi_dz
three_hours_phi_dz = phi_dz * 3
return(three_hours_phi_dz)
}
calculate_phi_dz = function(place, three_hour, layer_no, day_arg, year_arg){
# T_wc is water surface temperature in Celsius
c_pw = 4.1816 # heat capacity of water, unit kJK-1kg-1
A_v = 1 # idealized volume element surface area
# Calculating T_wc or water temperature in 0 C
heat_layers = read.csv("simulated_data.csv")
heat_layers = heat_layers[heat_layers$layer == layer_no, ]
heat_layers = heat_layers[heat_layers$area == areas[place], ]
if(three_hour!=1){
heat_layers = heat_layers[heat_layers$time == time_of_the_day[three_hour-1], ] # Get the heat content computed for the last three-hour time period
} else{
heat_layers = heat_layers[heat_layers$time == time_of_the_day[8], ] # Get the heat content computed for the last three-hour time period
}
heat_layers = heat_layers[heat_layers$day == day_arg, ]
heat_layers =  heat_layers[heat_layers$year == year_arg, ]
T_wc = heat_layers$temp
# Calculating rho_w
rho_w = (0.99987 + (0.69 * (10 ** (-5))) * T_wc) - ((8.89 * (10 ** (-6))) * (T_wc)**2) + ((7.4 * (10 ** (-8))) * (T_wc ** 3)) * 1000
phi_dz = T_wc * rho_w * c_pw * A_v
# Calculate and return three-hourly phi_dz
three_hours_phi_dz = phi_dz * 3
return(three_hours_phi_dz)
}
calculate_phi_dz(1, 4, 1, 1, 2001)
calculate_phi_dz(1, 4, 1, 1, 2001)
calculate_phi_dz(1, 4, 1, 1, 2017)
